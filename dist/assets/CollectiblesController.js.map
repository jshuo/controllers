{"version":3,"file":"CollectiblesController.js","sourceRoot":"","sources":["../../src/assets/CollectiblesController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { Mutex } from 'async-mutex';\nimport { BaseController, BaseConfig, BaseState } from '../BaseController';\nimport type { PreferencesState } from '../user/PreferencesController';\nimport type { NetworkState, NetworkType } from '../network/NetworkController';\nimport { safelyExecute, handleFetch, toChecksumHexAddress } from '../util';\nimport { MAINNET } from '../constants';\nimport type {\n  ApiCollectible,\n  ApiCollectibleCreator,\n  ApiCollectibleContract,\n  ApiCollectibleLastSale,\n} from './AssetsDetectionController';\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareCollectiblesMetadata } from './assetsUtil';\n\n/**\n * @type Collectible\n *\n * Collectible representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The collectible description\n * @property image - URI of custom collectible image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The collectible identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this collectible\n * @property imageThumbnail - URI of a thumbnail image associated with this collectible\n * @property imageOriginal - URI of the original image associated with this collectible\n * @property animation - URI of a animation associated with this collectible\n * @property animationOriginal - URI of the original animation associated with this collectible\n * @property externalLink - External link containing additional information\n * @property creator - The collectible owner information object\n */\nexport interface Collectible extends CollectibleMetadata {\n  tokenId: number;\n  address: string;\n}\n\n/**\n * @type CollectibleContract\n *\n * Collectible contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of collectibles\n * @property assetContractType - The collectible type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\nexport interface CollectibleContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type CollectibleMetadata\n *\n * Collectible custom information\n * @property name - Collectible custom name\n * @property description - The collectible description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this collectible\n * @property imageThumbnail - URI of a thumbnail image associated with this collectible\n * @property imageOriginal - URI of the original image associated with this collectible\n * @property animation - URI of a animation associated with this collectible\n * @property animationOriginal - URI of the original animation associated with this collectible\n * @property externalLink - External link containing additional information\n * @property creator - The collectible owner information object\n */\nexport interface CollectibleMetadata {\n  name?: string;\n  description?: string;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  image?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: ApiCollectibleCreator;\n  lastSale?: ApiCollectibleLastSale;\n}\n\n/**\n * @type CollectiblesConfig\n *\n * Collectibles controller configuration\n * @property networkType - Network ID as per net_version\n * @property selectedAddress - Vault selected address\n */\nexport interface CollectiblesConfig extends BaseConfig {\n  networkType: NetworkType;\n  selectedAddress: string;\n  chainId: string;\n}\n\n/**\n * @type CollectiblesState\n *\n * Assets controller state\n * @property allCollectibleContracts - Object containing collectibles contract information\n * @property allCollectibles - Object containing collectibles per account and network\n * @property collectibleContracts - List of collectibles contracts associated with the active vault\n * @property collectibles - List of collectibles associated with the active vault\n * @property ignoredCollectibles - List of collectibles that should be ignored\n */\nexport interface CollectiblesState extends BaseState {\n  allCollectibleContracts: {\n    [key: string]: { [key: string]: CollectibleContract[] };\n  };\n  allCollectibles: { [key: string]: { [key: string]: Collectible[] } };\n  collectibleContracts: CollectibleContract[];\n  collectibles: Collectible[];\n  ignoredCollectibles: Collectible[];\n}\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class CollectiblesController extends BaseController<\n  CollectiblesConfig,\n  CollectiblesState\n> {\n  private mutex = new Mutex();\n\n  private getCollectibleApi(contractAddress: string, tokenId: number) {\n    return `https://api.opensea.io/api/v1/asset/${contractAddress}/${tokenId}`;\n  }\n\n  private getCollectibleContractInformationApi(contractAddress: string) {\n    return `https://api.opensea.io/api/v1/asset_contract/${contractAddress}`;\n  }\n\n  /**\n   * Request individual collectible information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   * @returns Promise resolving to the current collectible name and image.\n   */\n  private async getCollectibleInformationFromApi(\n    contractAddress: string,\n    tokenId: number,\n  ): Promise<CollectibleMetadata> {\n    const tokenURI = this.getCollectibleApi(contractAddress, tokenId);\n    let collectibleInformation: ApiCollectible;\n    /* istanbul ignore if */\n    if (this.openSeaApiKey) {\n      collectibleInformation = await handleFetch(tokenURI, {\n        headers: { 'X-API-KEY': this.openSeaApiKey },\n      });\n    } else {\n      collectibleInformation = await handleFetch(tokenURI);\n    }\n    const {\n      num_sales,\n      background_color,\n      image_url,\n      image_preview_url,\n      image_thumbnail_url,\n      image_original_url,\n      animation_url,\n      animation_original_url,\n      name,\n      description,\n      external_link,\n      creator,\n      last_sale,\n    } = collectibleInformation;\n\n    /* istanbul ignore next */\n    const collectibleMetadata: CollectibleMetadata = Object.assign(\n      {},\n      { name },\n      creator && { creator },\n      description && { description },\n      image_url && { image: image_url },\n      num_sales && { numberOfSales: num_sales },\n      background_color && { backgroundColor: background_color },\n      image_preview_url && { imagePreview: image_preview_url },\n      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n      image_original_url && { imageOriginal: image_original_url },\n      animation_url && { animation: animation_url },\n      animation_original_url && {\n        animationOriginal: animation_original_url,\n      },\n      external_link && { externalLink: external_link },\n      last_sale && { lastSale: last_sale },\n    );\n\n    return collectibleMetadata;\n  }\n\n  /**\n   * Request individual collectible information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   * @returns Promise resolving to the current collectible name and image.\n   */\n  private async getCollectibleInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: number,\n  ): Promise<CollectibleMetadata> {\n    const tokenURI = await this.getCollectibleTokenURI(\n      contractAddress,\n      tokenId,\n    );\n    const object = await handleFetch(tokenURI);\n    const image = Object.prototype.hasOwnProperty.call(object, 'image')\n      ? 'image'\n      : /* istanbul ignore next */ 'image_url';\n    return { image: object[image], name: object.name };\n  }\n\n  /**\n   * Request individual collectible information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   * @returns Promise resolving to the current collectible name and image.\n   */\n  private async getCollectibleInformation(\n    contractAddress: string,\n    tokenId: number,\n  ): Promise<CollectibleMetadata> {\n    let information;\n    // First try with OpenSea\n    information = await safelyExecute(async () => {\n      return await this.getCollectibleInformationFromApi(\n        contractAddress,\n        tokenId,\n      );\n    });\n\n    if (information) {\n      return information;\n    }\n\n    // Then following ERC721 standard\n    information = await safelyExecute(async () => {\n      return await this.getCollectibleInformationFromTokenURI(\n        contractAddress,\n        tokenId,\n      );\n    });\n\n    /* istanbul ignore next */\n    if (information) {\n      return information;\n    }\n    /* istanbul ignore next */\n    return {};\n  }\n\n  /**\n   * Request collectible contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @returns Promise resolving to the current collectible name and image.\n   */\n  private async getCollectibleContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiCollectibleContract> {\n    const api = this.getCollectibleContractInformationApi(contractAddress);\n    let apiCollectibleContractObject: ApiCollectibleContract;\n    /* istanbul ignore if */\n    if (this.openSeaApiKey) {\n      apiCollectibleContractObject = await handleFetch(api, {\n        headers: { 'X-API-KEY': this.openSeaApiKey },\n      });\n    } else {\n      apiCollectibleContractObject = await handleFetch(api);\n    }\n    return apiCollectibleContractObject;\n  }\n\n  /**\n   * Request collectible contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @returns Promise resolving to the current collectible name and image.\n   */\n  private async getCollectibleContractInformationFromContract(\n    contractAddress: string,\n  ): Promise<ApiCollectibleContract> {\n    const name = await this.getAssetName(contractAddress);\n    const symbol = await this.getAssetSymbol(contractAddress);\n    return {\n      name,\n      symbol,\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      image_url: null,\n    };\n  }\n\n  /**\n   * Request collectible contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @returns Promise resolving to the collectible contract name, image and description.\n   */\n  private async getCollectibleContractInformation(\n    contractAddress: string,\n  ): Promise<ApiCollectibleContract> {\n    let information;\n    // First try with OpenSea\n    information = await safelyExecute(async () => {\n      return await this.getCollectibleContractInformationFromApi(\n        contractAddress,\n      );\n    });\n\n    if (information) {\n      return information;\n    }\n\n    // Then following ERC721 standard\n    information = await safelyExecute(async () => {\n      return await this.getCollectibleContractInformationFromContract(\n        contractAddress,\n      );\n    });\n\n    if (information) {\n      return information;\n    }\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      name: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      image_url: null,\n    };\n  }\n\n  /**\n   * Adds an individual collectible to the stored collectible list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   * @param collectibleMetadata - Collectible optional information (name, image and description).\n   * @returns Promise resolving to the current collectible list.\n   */\n  private async addIndividualCollectible(\n    address: string,\n    tokenId: number,\n    collectibleMetadata?: CollectibleMetadata,\n  ): Promise<Collectible[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allCollectibles, collectibles } = this.state;\n      const { chainId, selectedAddress } = this.config;\n      const existingEntry: Collectible | undefined = collectibles.find(\n        (collectible) =>\n          collectible.address.toLowerCase() === address.toLowerCase() &&\n          collectible.tokenId === tokenId,\n      );\n      /* istanbul ignore next */\n      collectibleMetadata =\n        collectibleMetadata ||\n        (await this.getCollectibleInformation(address, tokenId));\n\n      if (existingEntry) {\n        const differentMetadata = compareCollectiblesMetadata(\n          collectibleMetadata,\n          existingEntry,\n        );\n        if (differentMetadata) {\n          const indexToRemove = collectibles.findIndex(\n            (collectible) =>\n              collectible.address.toLowerCase() === address.toLowerCase() &&\n              collectible.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            collectibles.splice(indexToRemove, 1);\n          }\n        } else {\n          return collectibles;\n        }\n      }\n\n      const newEntry: Collectible = {\n        address,\n        tokenId,\n        ...collectibleMetadata,\n      };\n      const newCollectibles = [...collectibles, newEntry];\n      const addressCollectibles = allCollectibles[selectedAddress];\n      const newAddressCollectibles = {\n        ...addressCollectibles,\n        ...{ [chainId]: newCollectibles },\n      };\n      const newAllCollectibles = {\n        ...allCollectibles,\n        ...{ [selectedAddress]: newAddressCollectibles },\n      };\n      this.update({\n        allCollectibles: newAllCollectibles,\n        collectibles: newCollectibles,\n      });\n      return newCollectibles;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds a collectible contract to the stored collectible contracts list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param detection - Whether the collectible is manually added or auto-detected.\n   * @returns Promise resolving to the current collectible contracts list.\n   */\n  private async addCollectibleContract(\n    address: string,\n    detection?: boolean,\n  ): Promise<CollectibleContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allCollectibleContracts, collectibleContracts } = this.state;\n      const { chainId, selectedAddress } = this.config;\n      const existingEntry = collectibleContracts.find(\n        (collectibleContract) =>\n          collectibleContract.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (existingEntry) {\n        return collectibleContracts;\n      }\n      const contractInformation = await this.getCollectibleContractInformation(\n        address,\n      );\n      const {\n        asset_contract_type,\n        created_date,\n        name,\n        schema_name,\n        symbol,\n        total_supply,\n        description,\n        external_link,\n        image_url,\n      } = contractInformation;\n      // If being auto-detected opensea information is expected\n      // Oherwise at least name and symbol from contract is needed\n      if (\n        (detection && !image_url) ||\n        Object.keys(contractInformation).length === 0\n      ) {\n        return collectibleContracts;\n      }\n      /* istanbul ignore next */\n      const newEntry: CollectibleContract = Object.assign(\n        {},\n        { address },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        total_supply !== null && { totalSupply: total_supply },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n\n      const newCollectibleContracts = [...collectibleContracts, newEntry];\n      const addressCollectibleContracts =\n        allCollectibleContracts[selectedAddress];\n      const newAddressCollectibleContracts = {\n        ...addressCollectibleContracts,\n        ...{ [chainId]: newCollectibleContracts },\n      };\n      const newAllCollectibleContracts = {\n        ...allCollectibleContracts,\n        ...{ [selectedAddress]: newAddressCollectibleContracts },\n      };\n      this.update({\n        allCollectibleContracts: newAllCollectibleContracts,\n        collectibleContracts: newCollectibleContracts,\n      });\n      return newCollectibleContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual collectible from the stored token list and saves it in ignored collectibles list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - Token identifier of the collectible.\n   */\n  private removeAndIgnoreIndividualCollectible(\n    address: string,\n    tokenId: number,\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allCollectibles, collectibles, ignoredCollectibles } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const newIgnoredCollectibles = [...ignoredCollectibles];\n    const newCollectibles = collectibles.filter((collectible) => {\n      if (\n        collectible.address.toLowerCase() === address.toLowerCase() &&\n        collectible.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredCollectibles.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredCollectibles.push(collectible);\n        return false;\n      }\n      return true;\n    });\n    const addressCollectibles = allCollectibles[selectedAddress];\n    const newAddressCollectibles = {\n      ...addressCollectibles,\n      ...{ [chainId]: newCollectibles },\n    };\n    const newAllCollectibles = {\n      ...allCollectibles,\n      ...{ [selectedAddress]: newAddressCollectibles },\n    };\n    this.update({\n      allCollectibles: newAllCollectibles,\n      collectibles: newCollectibles,\n      ignoredCollectibles: newIgnoredCollectibles,\n    });\n  }\n\n  /**\n   * Removes an individual collectible from the stored token list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - Token identifier of the collectible.\n   */\n  private removeIndividualCollectible(address: string, tokenId: number) {\n    address = toChecksumHexAddress(address);\n    const { allCollectibles, collectibles } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const newCollectibles = collectibles.filter(\n      (collectible) =>\n        !(\n          collectible.address.toLowerCase() === address.toLowerCase() &&\n          collectible.tokenId === tokenId\n        ),\n    );\n    const addressCollectibles = allCollectibles[selectedAddress];\n    const newAddressCollectibles = {\n      ...addressCollectibles,\n      ...{ [chainId]: newCollectibles },\n    };\n    const newAllCollectibles = {\n      ...allCollectibles,\n      ...{ [selectedAddress]: newAddressCollectibles },\n    };\n    this.update({\n      allCollectibles: newAllCollectibles,\n      collectibles: newCollectibles,\n    });\n  }\n\n  /**\n   * Removes a collectible contract to the stored collectible contracts list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @returns Promise resolving to the current collectible contracts list.\n   */\n  private removeCollectibleContract(address: string): CollectibleContract[] {\n    address = toChecksumHexAddress(address);\n    const { allCollectibleContracts, collectibleContracts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const newCollectibleContracts = collectibleContracts.filter(\n      (collectibleContract) =>\n        !(collectibleContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    const addressCollectibleContracts =\n      allCollectibleContracts[selectedAddress];\n    const newAddressCollectibleContracts = {\n      ...addressCollectibleContracts,\n      ...{ [chainId]: newCollectibleContracts },\n    };\n    const newAllCollectibleContracts = {\n      ...allCollectibleContracts,\n      ...{ [selectedAddress]: newAddressCollectibleContracts },\n    };\n    this.update({\n      allCollectibleContracts: newAllCollectibleContracts,\n      collectibleContracts: newCollectibleContracts,\n    });\n    return newCollectibleContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'CollectiblesController';\n\n  private getAssetName: AssetsContractController['getAssetName'];\n\n  private getAssetSymbol: AssetsContractController['getAssetSymbol'];\n\n  private getCollectibleTokenURI: AssetsContractController['getCollectibleTokenURI'];\n\n  /**\n   * Creates a CollectiblesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getAssetName - Gets the name of the asset at the given address.\n   * @param options.getAssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getCollectibleTokenURI - Gets the URI of the NFT at the given address, with the given ID.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getAssetName,\n      getAssetSymbol,\n      getCollectibleTokenURI,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getAssetName: AssetsContractController['getAssetName'];\n      getAssetSymbol: AssetsContractController['getAssetSymbol'];\n      getCollectibleTokenURI: AssetsContractController['getCollectibleTokenURI'];\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<CollectiblesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      networkType: MAINNET,\n      selectedAddress: '',\n      chainId: '',\n    };\n\n    this.defaultState = {\n      allCollectibleContracts: {},\n      allCollectibles: {},\n      collectibleContracts: [],\n      collectibles: [],\n      ignoredCollectibles: [],\n    };\n    this.initialize();\n    this.getAssetName = getAssetName;\n    this.getAssetSymbol = getAssetSymbol;\n    this.getCollectibleTokenURI = getCollectibleTokenURI;\n    onPreferencesStateChange(({ selectedAddress }) => {\n      const { allCollectibleContracts, allCollectibles } = this.state;\n      const { chainId } = this.config;\n      this.configure({ selectedAddress });\n      this.update({\n        collectibleContracts:\n          allCollectibleContracts[selectedAddress]?.[chainId] || [],\n        collectibles: allCollectibles[selectedAddress]?.[chainId] || [],\n      });\n    });\n\n    onNetworkStateChange(({ provider }) => {\n      const { allCollectibleContracts, allCollectibles } = this.state;\n      const { selectedAddress } = this.config;\n      const { chainId } = provider;\n      this.configure({ chainId });\n      this.update({\n        collectibleContracts:\n          allCollectibleContracts[selectedAddress]?.[chainId] || [],\n        collectibles: allCollectibles[selectedAddress]?.[chainId] || [],\n      });\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve collectible information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Adds a collectible and respective collectible contract to the stored collectible and collectible contracts lists.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   * @param collectibleMetadata - Collectible optional metadata.\n   * @param detection - Whether the collectible is manually added or autodetected.\n   * @returns Promise resolving to the current collectible list.\n   */\n  async addCollectible(\n    address: string,\n    tokenId: number,\n    collectibleMetadata?: CollectibleMetadata,\n    detection?: boolean,\n  ) {\n    address = toChecksumHexAddress(address);\n    const newCollectibleContracts = await this.addCollectibleContract(\n      address,\n      detection,\n    );\n\n    collectibleMetadata =\n      collectibleMetadata ||\n      (await this.getCollectibleInformation(address, tokenId));\n\n    // If collectible contract was not added, do not add individual collectible\n    const collectibleContract = newCollectibleContracts.find(\n      (contract) => contract.address.toLowerCase() === address.toLowerCase(),\n    );\n    // If collectible contract information, add individual collectible\n    if (collectibleContract) {\n      await this.addIndividualCollectible(\n        address,\n        tokenId,\n        collectibleMetadata,\n      );\n    }\n  }\n\n  /**\n   * Removes a collectible from the stored token list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - Token identifier of the collectible.\n   */\n  removeCollectible(address: string, tokenId: number) {\n    address = toChecksumHexAddress(address);\n    this.removeIndividualCollectible(address, tokenId);\n    const { collectibles } = this.state;\n    const remainingCollectible = collectibles.find(\n      (collectible) =>\n        collectible.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingCollectible) {\n      this.removeCollectibleContract(address);\n    }\n  }\n\n  /**\n   * Removes a collectible from the stored token list and saves it in ignored collectibles list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - Token identifier of the collectible.\n   */\n  removeAndIgnoreCollectible(address: string, tokenId: number) {\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualCollectible(address, tokenId);\n    const { collectibles } = this.state;\n    const remainingCollectible = collectibles.find(\n      (collectible) =>\n        collectible.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingCollectible) {\n      this.removeCollectibleContract(address);\n    }\n  }\n\n  /**\n   * Removes all collectibles from the ignored list.\n   */\n  clearIgnoredCollectibles() {\n    this.update({ ignoredCollectibles: [] });\n  }\n}\n\nexport default CollectiblesController;\n"]}